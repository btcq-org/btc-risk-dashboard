#!/usr/bin/env python3
"""
UTXO Analyzer for Bitcoin Core dumptxoutset File

This script reads a `utxo.dat` file generated by `bitcoin-cli dumptxoutset` (Bitcoin Core v0.21+)
and analyzes the UTXO types and their total balances.

The format includes a 55-byte header (magic, version, network, height, base hash, coin count)
followed by grouped UTXO records: txid (32B), compact num_outputs, then per output: vout (4B),
height (4B), amount (8B), compact script_len, scriptPubKey.

Usage:
    python utxo_analyzer.py utxo-880000.dat

Output: Prints header info and a table of UTXO types with counts and total balance (in BTC).
"""

import argparse
import struct
import sys
from collections import defaultdict
from typing import Dict
from bitcoin.core import CScript
from bitcoin.wallet import CBitcoinAddress
from bitcoin import SelectParams
from pycoin.symbols.btc import network

SelectParams('mainnet')

def _read_exact(f, n: int) -> bytes:
    data = f.read(n)
    if len(data) != n:
        raise ValueError("Unexpected EOF while reading")
    return data

def read_compactsize(f) -> int:
    """
    Read Bitcoin CompactSize integer from file-like object `f`.
    """
    first = _read_exact(f, 1)[0]
    if first < 253:
        return first
    if first == 253:
        return struct.unpack('<H', _read_exact(f, 2))[0]
    if first == 254:
        return struct.unpack('<I', _read_exact(f, 4))[0]
    if first == 255:
        return struct.unpack('<Q', _read_exact(f, 8))[0]
    
    return 0

def read_varint(f) -> int:
    """
    Read custom 7-bit continuation varint used in dumptxoutset.
    """
    result = 0
    for _ in range(9):
        next_byte = _read_exact(f, 1)[0]
        result <<= 7
        result += (next_byte & 0x7F)
        if next_byte & 0x80:
            result += 1
        else:
            return result
    raise ValueError("Too big read_varint")

def decompress_amount(x) -> int:
    if x == 0:
        return 0

    x -= 1
    e = x % 10
    x /= 10
    n = 0
    if e < 9:
        d = (x % 9) + 1
        x /= 9
        n = x * 10 + d
    else:
        n = x + 1
    
    while e > 0:
        n *= 10
        e -= 1
    
    return n


def classify_script(script: bytes) -> str:
    """
    Classify the scriptPubKey type.
    Returns a string like 'P2PKH', 'P2SH', 'P2WPKH', 'P2PK', 'P2WSH', 'nonstandard'.
    """
    if not script:
        return 'null'

    # P2WPKH: OP_0 PUSH 20-byte key hash (0x0014 + 20 bytes)
    if len(script) == 22 and script[0] == 0x00 and script[1] == 0x14:
        return 'P2WPKH'

    # P2WSH: OP_0 PUSH 32-byte script hash (0x0020 + 32 bytes)
    if len(script) == 34 and script[0] == 0x00 and script[1] == 0x20:
        return 'P2WSH'

    # P2PKH: OP_DUP OP_HASH160 <20> OP_EQUALVERIFY OP_CHECKSIG (76a914<20>88ac)
    if len(script) == 25 and script[0] == 0x76 and script[1] == 0xa9 and script[23] == 0x88 and script[24] == 0xac:
        return 'P2PKH'

    # P2SH: OP_HASH160 <20> OP_EQUAL (a914<20>87)
    if len(script) == 23 and script[0] == 0xa9 and script[1] == 0x14 and script[22] == 0x87:
        return 'P2SH'

    # P2PK: PUSH <pubkey> OP_CHECKSIG (e.g., 41<65 bytes>ac for uncompressed)
    if len(script) > 2 and script[-1] == 0xac and script[0] in (0x21, 0x41):  # Push 33/65 bytes
        pubkey_len = script[0]
        if len(script) == pubkey_len + 2:
            return 'P2PK'

    return 'nonstandard'

def read_utxo_file(filename: str) -> None:
    """
    Read and analyze the UTXO file.
    """
    with open(filename, 'rb') as f:
        # Header: 55 bytes
        magic = f.read(5)
        if magic != b'utxo\xff':
            raise ValueError(f"Invalid magic bytes: {magic.hex()} (expected 'utxo\\xff')")

        version_data = f.read(2)
        if len(version_data) != 2:
            raise ValueError("File too short for version")
        version = struct.unpack('<H', version_data)[0]

        network_magic = f.read(4)
        if len(network_magic) != 4:
            raise ValueError("File too short for network magic")

        base_hash = f.read(32)
        if len(base_hash) != 32:
            raise ValueError("File too short for base hash")

        count_data = f.read(8)
        if len(count_data) != 8:
            raise ValueError("File too short for count")
        num_utxos = struct.unpack('<Q', count_data)[0]

        print(f"Format version: {version}")
        print(f"Network magic: {network_magic.hex()}")
        print(f"Base block hash: {base_hash[::-1].hex()}")
        print(f"Total UTXOs: {num_utxos:,}")

        type_stats = defaultdict(lambda: {'count': 0, 'total_sat': 0})
        parsed_utxos = 0

        # Asserting
        expected_header_start = b'utxo\xff\x02\x00\xf9\xbe\xb4\xd9'
        actual_header_start = magic + version_data + network_magic
        if actual_header_start != expected_header_start:
            print(f"Warning: Header start does not match expected v30 mainnet format.")
            print(f"Expected: {expected_header_start.hex()}")
            print(f"Actual:   {actual_header_start.hex()}")

        # This loop reads grouped UTXO records
        while parsed_utxos < num_utxos:
            # txid: 32 bytes (LE)
            txid_bytes = f.read(32)
            if len(txid_bytes) < 32:
                raise ValueError("File too short for txid")

            # num_outputs: CompactSize
            coins_per_hash = read_compactsize(f)

            if parsed_utxos >= 1:
                return

            for i in range(coins_per_hash):
                if parsed_utxos >= num_utxos:
                    raise ValueError("More UTXOs parsed than announced")

                print(f"Reading {txid_bytes[::-1].hex()} output {i}")

                height = read_compactsize(f)
                code = f.read(3)
                amount = decompress_amount(read_varint(f))

                print(f"  height: {height}, amount: {amount} satoshis")

                # size = read_varint(f)
                # print(f"  script size: {size} bytes")
                
                scriptpubkey = f.read(32)
                print(scriptpubkey.hex())
                address = network.address.for_script(bytes.fromhex('41047a488354d9d5414de09b7121b80b973c991b76998ad68756d8cf4560c0ddcbe24ae72a77cca86f6d1d11b1b796e3f14caa5852e6d4c60e9bebedc71673b58ec0ac'))
                print(f"  address: {address}")
                # intersting = read_scriptpubkey(f)

                # # vout: uint32 LE
                # vout_data = f.read(4)
                # if len(vout_data) < 4:
                #     raise ValueError("File too short for vout")
                # vout = struct.unpack('<I', vout_data)[0]

                # print(f"  vout: {vout}")

                # # height: uint32 LE
                # height_data = f.read(4)
                # if len(height_data) < 4:
                #     raise ValueError("File too short for height")
                # height = struct.unpack('<I', height_data)[0]

                # # amount: int64 LE (satoshis)
                # amount_data = f.read(8)
                # if len(amount_data) < 8:
                #     raise ValueError("File too short for amount")
                # amount_sat = struct.unpack('<q', amount_data)[0]

                # # script_len: CompactSize
                # script_len = read_compactsize(f)

                # # scriptPubKey: script_len bytes
                # script = f.read(script_len)
                # if len(script) < script_len:
                #     raise ValueError("File too short for scriptPubKey")

                # Classify type
                # utxo_type = classify_script(script)
                # type_stats[utxo_type]['count'] += 1
                # type_stats[utxo_type]['total_sat'] += amount_sat

                parsed_utxos += 1

        if parsed_utxos != num_utxos:
            raise ValueError(f"Parsed {parsed_utxos} UTXOs, expected {num_utxos}")

        # Output summary table
        print("\nUTXO Type Summary:")
        print(f"{'Type':<12} {'Count':<12} {'Total Balance (BTC)':<20}")
        print("-" * 44)
        total_btc = 0
        for utxo_type, stats in sorted(type_stats.items()):
            balance_btc = stats['total_sat'] / 100_000_000.0
            total_btc += balance_btc
            print(f"{utxo_type:<12} {stats['count']:<12,} {balance_btc:<20.8f}")

        print("-" * 44)
        print(f"{'GRAND TOTAL':<12} {num_utxos:<12,} {total_btc:<20.8f}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyze Bitcoin UTXO dump file.")
    parser.add_argument("filename", help="Path to utxo.dat file (e.g., utxo-880000.dat)")
    args = parser.parse_args()

    try:
        read_utxo_file(args.filename)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)