#!/usr/bin/env python3
"""
UTXO Analyzer for Bitcoin Core dumptxoutset File

This script reads a `utxo.dat` file generated by `bitcoin-cli dumptxoutset` (Bitcoin Core v0.21+)
and analyzes the UTXO types and their total balances.

The format includes a 55-byte header (magic, version, network, height, base hash, coin count)
followed by grouped UTXO records: txid (32B), compact num_outputs, then per output: vout (4B),
height (4B), amount (8B), compact script_len, scriptPubKey.

Usage:
    python utxo_analyzer.py utxo-880000.dat

Output: Prints header info and a table of UTXO types with counts and total balance (in BTC).
"""

import argparse
import struct
import sys
from collections import defaultdict
from typing import Dict




def _read_exact(f, n: int) -> bytes:
    data = f.read(n)
    if len(data) != n:
        raise ValueError("Unexpected EOF while reading")
    return data

def read_compactsize(f) -> int:
    """
    Read Bitcoin CompactSize integer from file-like object `f`.
    """
    first = _read_exact(f, 1)[0]
    if first < 253:
        return first
    if first == 253:
        return struct.unpack('<H', _read_exact(f, 2))[0]
    if first == 254:
        return struct.unpack('<I', _read_exact(f, 4))[0]
    if first == 255:
        return struct.unpack('<Q', _read_exact(f, 8))[0]
    
    return 0

def read_varint(f) -> int:
    """
    Read custom 7-bit continuation varint used in dumptxoutset.
    """
    result = 0
    for _ in range(9):
        next_byte = _read_exact(f, 1)[0]
        result <<= 7
        result += (next_byte & 0x7F)
        if next_byte & 0x80:
            result += 1
        else:
            return result
    raise ValueError("Too big read_varint")

def classify_script(script: bytes) -> str:
    """
    Classify the scriptPubKey type.
    Returns a string like 'P2PKH', 'P2SH', 'P2WPKH', 'P2PK', 'P2WSH', 'nonstandard'.
    """
    if not script:
        return 'null'

    # P2WPKH: OP_0 PUSH 20-byte key hash (0x0014 + 20 bytes)
    if len(script) == 22 and script[0] == 0x00 and script[1] == 0x14:
        return 'P2WPKH'

    # P2WSH: OP_0 PUSH 32-byte script hash (0x0020 + 32 bytes)
    if len(script) == 34 and script[0] == 0x00 and script[1] == 0x20:
        return 'P2WSH'

    # P2PKH: OP_DUP OP_HASH160 <20> OP_EQUALVERIFY OP_CHECKSIG (76a914<20>88ac)
    if len(script) == 25 and script[0] == 0x76 and script[1] == 0xa9 and script[23] == 0x88 and script[24] == 0xac:
        return 'P2PKH'

    # P2SH: OP_HASH160 <20> OP_EQUAL (a914<20>87)
    if len(script) == 23 and script[0] == 0xa9 and script[1] == 0x14 and script[22] == 0x87:
        return 'P2SH'

    # P2PK: PUSH <pubkey> OP_CHECKSIG (e.g., 41<65 bytes>ac for uncompressed)
    if len(script) > 2 and script[-1] == 0xac and script[0] in (0x21, 0x41):  # Push 33/65 bytes
        pubkey_len = script[0]
        if len(script) == pubkey_len + 2:
            return 'P2PK'

    return 'nonstandard'

def read_utxo_file(filename: str) -> None:
    """
    Read and analyze the UTXO file.
    """
    with open(filename, 'rb') as f:
        # Header: 55 bytes
        magic = f.read(5)
        if magic != b'utxo\xff':
            raise ValueError(f"Invalid magic bytes: {magic.hex()} (expected 'utxo\\xff')")

        version_data = f.read(2)
        if len(version_data) != 2:
            raise ValueError("File too short for version")
        version = struct.unpack('<H', version_data)[0]

        network_magic = f.read(4)
        if len(network_magic) != 4:
            raise ValueError("File too short for network magic")

        base_hash = f.read(32)
        if len(base_hash) != 32:
            raise ValueError("File too short for base hash")

        count_data = f.read(8)
        if len(count_data) != 8:
            raise ValueError("File too short for count")
        num_utxos = struct.unpack('<Q', count_data)[0]

        print(f"Format version: {version}")
        print(f"Network magic: {network_magic.hex()}")
        print(f"Base block hash: {base_hash[::-1].hex()}")
        print(f"Total UTXOs: {num_utxos:,}")

        type_stats = defaultdict(lambda: {'count': 0, 'total_sat': 0})
        parsed_utxos = 0

        # Asserting
        expected_header_start = b'utxo\xff\x02\x00\xf9\xbe\xb4\xd9'
        actual_header_start = magic + version_data + network_magic
        if actual_header_start != expected_header_start:
            print(f"Warning: Header start does not match expected v30 mainnet format.")
            print(f"Expected: {expected_header_start.hex()}")
            print(f"Actual:   {actual_header_start.hex()}")

        while parsed_utxos < num_utxos:
            # txid: 32 bytes (LE)
            txid_bytes = f.read(32)
            if len(txid_bytes) < 32:
                raise ValueError("File too short for txid")

            # num_outputs: CompactSize
            num_outputs = read_compactsize(f)

            for _ in range(num_outputs):
                if parsed_utxos >= num_utxos:
                    raise ValueError("More UTXOs parsed than announced")

                # vout: uint32 LE
                vout_data = f.read(4)
                if len(vout_data) < 4:
                    raise ValueError("File too short for vout")
                vout = struct.unpack('<I', vout_data)[0]

                # height: uint32 LE
                height_data = f.read(4)
                if len(height_data) < 4:
                    raise ValueError("File too short for height")
                height = struct.unpack('<I', height_data)[0]

                # amount: int64 LE (satoshis)
                amount_data = f.read(8)
                if len(amount_data) < 8:
                    raise ValueError("File too short for amount")
                amount_sat = struct.unpack('<q', amount_data)[0]

                # script_len: CompactSize
                script_len = read_compactsize(f)

                # scriptPubKey: script_len bytes
                script = f.read(script_len)
                if len(script) < script_len:
                    raise ValueError("File too short for scriptPubKey")

                # Classify type
                utxo_type = classify_script(script)
                type_stats[utxo_type]['count'] += 1
                type_stats[utxo_type]['total_sat'] += amount_sat

                parsed_utxos += 1

        if parsed_utxos != num_utxos:
            raise ValueError(f"Parsed {parsed_utxos} UTXOs, expected {num_utxos}")

        # Output summary table
        print("\nUTXO Type Summary:")
        print(f"{'Type':<12} {'Count':<12} {'Total Balance (BTC)':<20}")
        print("-" * 44)
        total_btc = 0
        for utxo_type, stats in sorted(type_stats.items()):
            balance_btc = stats['total_sat'] / 100_000_000.0
            total_btc += balance_btc
            print(f"{utxo_type:<12} {stats['count']:<12,} {balance_btc:<20.8f}")

        print("-" * 44)
        print(f"{'GRAND TOTAL':<12} {num_utxos:<12,} {total_btc:<20.8f}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyze Bitcoin UTXO dump file.")
    parser.add_argument("filename", help="Path to utxo.dat file (e.g., utxo-880000.dat)")
    args = parser.parse_args()

    try:
        read_utxo_file(args.filename)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)